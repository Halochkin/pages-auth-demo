function toBase64url(base64str) {
  return btoa(base64str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}

function fromBase64url(base64urlStr) {
  base64urlStr = base64urlStr.replace(/-/g, '+').replace(/_/g, '/');
  if (base64urlStr.length % 4 === 2)
    base64urlStr += '==';
  else if (base64urlStr.length % 4 === 3)
    base64urlStr += '=';
  return atob(base64urlStr);
}

const algorithms = {
  ES256: {name: 'ECDSA', namedCurve: 'P-256', hash: {name: 'SHA-256'}},
  ES384: {name: 'ECDSA', namedCurve: 'P-384', hash: {name: 'SHA-384'}},
  ES512: {name: 'ECDSA', namedCurve: 'P-521', hash: {name: 'SHA-512'}},
  HS256: {name: 'HMAC', hash: {name: 'SHA-256'}},
  HS384: {name: 'HMAC', hash: {name: 'SHA-384'}},
  HS512: {name: 'HMAC', hash: {name: 'SHA-512'}},
  RS256: {name: 'RSASSA-PKCS1-v1_5', hash: {name: 'SHA-256'}},
  RS384: {name: 'RSASSA-PKCS1-v1_5', hash: {name: 'SHA-384'}},
  RS512: {name: 'RSASSA-PKCS1-v1_5', hash: {name: 'SHA-512'}}
};
function _str2ab(str) {
  str = atob(str);
  const buf = new ArrayBuffer(str.length);
  const bufView = new Uint8Array(buf);
  for (let i = 0; i < str.length; i++)
    bufView[i] = str.charCodeAt(i);
  return buf;
}

function prepPKCS8(secret) {
  secret = secret.replace(/-----BEGIN.*?-----/g, '').replace(/-----END.*?-----/g, '').replace(/\s/g, '');
  return _str2ab(secret);
}

/**
 * Signs a payload and returns the token
 *
 * @param {JwtPayload} payload The payload object. To use `nbf` (Not Before) and/or `exp` (Expiration Time) add `nbf` and/or `exp` to the payload.
 * @param {string} secret A string which is used to sign the payload.
 * @param {JwtSignOptions | JwtAlgorithm | string} [options={ algorithm: 'HS256', header: { typ: 'JWT' } }] The options object or the algorithm.
 * @throws {Error} If there's a validation issue.
 * @returns {Promise<string>} Returns token as a `string`.
 */
export async function sign(payload, secret, options = {algorithm: 'HS256', header: {typ: 'JWT'}}) {
  if (typeof options === 'string')
    options = {algorithm: options, header: {typ: 'JWT'}};
  options = {algorithm: 'HS256', header: {typ: 'JWT'}, ...options};
  if (payload === null || typeof payload !== 'object')
    throw new Error('payload must be an object');
  if (typeof secret !== 'string')
    throw new Error('secret must be a string');
  if (typeof options.algorithm !== 'string')
    throw new Error('options.algorithm must be a string');
  const algorithm = algorithms[options.algorithm];
  if (!algorithm)
    throw new Error('algorithm not found');
  if (!payload.iat)
    payload.iat = Math.floor(Date.now() / 1000);

  const payloadAsJSON = JSON.stringify(payload);
  let p = toBase64url(payloadAsJSON);

  let obj = {...options.header, alg: options.algorithm};
  let stringify = JSON.stringify(obj);
  let h = toBase64url(stringify);

  const partialToken = `${h}.${p}`;
  let keyFormat = 'raw';
  let keyData = secret;
  if (secret.startsWith('-----BEGIN')) {
    keyFormat = 'pkcs8';
    keyData = prepPKCS8(secret);
  }
  // else
  //   keyData = _utf8ToUint8Array(secret);
  const key = await crypto.subtle.importKey(keyFormat, keyData, algorithm, false, ['sign']);
  const signature = await crypto.subtle.sign(algorithm, key, partialToken);//_utf8ToUint8Array(partialToken));
  const three = String.fromCharCode.apply(0, new Uint8Array(signature));
  const threeB = toBase64url(three);
  return `${partialToken}.${threeB}`;
}

/**
 * Verifies the integrity of the token and returns a boolean value.
 *
 * @param {string} token The token string generated by `jwt.sign()`.
 * @param {string} secret The string which was used to sign the payload.
 * @param {JWTVerifyOptions | JWTAlgorithm} options The options object or the algorithm.
 * @throws {Error | string} Throws an error `string` if the token is invalid or an `Error-Object` if there's a validation issue.
 * @returns {Promise<boolean>} Returns `true` if signature, `nbf` (if set) and `exp` (if set) are valid, otherwise returns `false`.
 */
export async function verify(token, secret, options = {algorithm: 'HS256', throwError: false}) {
  if (typeof options === 'string')
    options = {algorithm: options, throwError: false};
  options = {algorithm: 'HS256', throwError: false, ...options};
  if (typeof token !== 'string')
    throw new Error('token must be a string');
  if (typeof secret !== 'string')
    throw new Error('secret must be a string');
  if (typeof options.algorithm !== 'string')
    throw new Error('options.algorithm must be a string');
  const tokenParts = token.split('.');
  if (tokenParts.length !== 3)
    throw new Error('token must consist of 3 parts');
  const algorithm = algorithms[options.algorithm];
  if (!algorithm)
    throw new Error('algorithm not found');
  const {header, payload} = decode(token);
  if (!payload) {
    if (options.throwError)
      throw 'PARSE_ERROR';
    return false;
  }
  if (payload.nbf && payload.nbf > Math.floor(Date.now() / 1000)) {
    if (options.throwError)
      throw 'NOT_YET_VALID';
    return false;
  }
  if (payload.exp && payload.exp <= Math.floor(Date.now() / 1000)) {
    if (options.throwError)
      throw 'EXPIRED';
    return false;
  }
  let keyFormat = 'raw';
  let keyData = secret;
  if (secret.startsWith('-----BEGIN')) {
    keyFormat = 'spki';
    keyData = prepPKCS8(secret);
  }
  // else
  //   keyData = _utf8ToUint8Array(secret);
  const key = await crypto.subtle.importKey(keyFormat, keyData, algorithm, false, ['verify']);
  const headerPayload = `${tokenParts[0]}.${tokenParts[1]}`;
  const signatureStr = fromBase64url(tokenParts[2]);
  const signature = new Uint8Array(Array.prototype.map.call(signatureStr, c => c.charCodeAt(0)))
  return await crypto.subtle.verify(algorithm, key, signature, headerPayload);
}

// exports.verify = verify;
/**
 * Returns the payload **without** verifying the integrity of the token. Please use `jwt.verify()` first to keep your application secure!
 *
 * @param {string} token The token string generated by `jwt.sign()`.
 * @returns {JwtData} Returns an `object` containing `header` and `payload`.
 */
export function decode(token) {
  const [header, payload] = token.split(".");
  return {
    header: JSON.parse(fromBase64url(header)),
    payload: JSON.parse(fromBase64url(payload))
  };
}